### Weekly Reflection #3
1. Explain what principles you apply to your project!
There are five principles that I have applied to this project. The first one is Single Responsibility Principle (SRP). Each class should have only one reason to change, focusing on a single functionality. For example, two controllers class CarController and Product Controller are made instead of the atrocious two classes in one big file because both controllers have two distinct responsibilities. The second principle is Open/Closed Principle, which says that a module should be open for extension but closed for modification. And I have applied this in separating ProductController from CarController, so that there is a possible future extension for any of them instead of tying one to another. Another more instructive example is the use of any interface (say 'CarRepoInterface') that one or more classes could implement, which allows the CarRepoInterface implementation to be extended or replaced without altering the flow of the program, adhering to the OCP. The third principle is Liskov Substitution Principle (LSP), which states objects of a superclass should be able to be replaced by objects of a subclass without affecting the correctness of the program.  For example, CarRepository implements the CarRepointerface interface, so any method in this project that uses the interface shall use the implementation Class without knowing the difference, which complies with LSP. And then the fourth principle is the Interface Segregation Principle (ISP). It says that no class should be forced to depend on methods of any interface it implements that it actually does not use. Well, the example for this is CarRepoInterface which only gives operations that CarRepository has to implement. The last one is Dependency Inversion Principle (DIP). It says high-level modules should not depend on low-level modules; both should depend on abstractions, and abstractions should not depend on details. And we have tried to apply this by allowing CarController depend on the CarService abstraction rather than any concrete implementation, which is injected by the annotation @Autowired. This inverses the dependency, allowing for decoupling of the controller from the details of service logic.
2. Explain the advantages of applying SOLID with examples!
Maintainability is an advantage. For example, adhering to SRP by having two distinct classes for the CarController and ProductController means each class has a single reason to change, such as modifying how products or cars are controlled. This makes the project easier to maintain because changes in how ProductController works does not affect functionalities of CarController. Another advantage is flexibility. For example, by adhering to the Dependency Inversion Principle, two classes depend on abstractions (CarService and CarRepoInterface) rather than concrete implementations. This flexibility will make it easier to change one aspect of the repository layer, for instance, without destroying others. Another nice advantage is Reusability. As an example, using interfaces and LSP means components like CarServiceImpl might one day be reused in different contexts, as long as the new context fits with the contract of the CarService interface.
3. Explain the disadvantages of applying SOLID with examples!
One is Tight Coupling. If we combine responsibilities, such as ProductController and CarController, would hinder the programmer ability to reuse the code in contexts where only product or car is needed, due to the unnecessary coupling of unrelated functionalities. Rigidity is another disadvantage. Imagine if CarServiceImpl directly instantiated CarRepository repositories instead of injecting it through an interface, adding a different data source code in the future would require modifying our service class directly, making our software rigid and annoying to adapt to new requirements.



